@JUEL_CHECK


@GETJUEL_SOURCE
#DIM NUM
#DIM LCOUNT
#DIM PALAMCOUNT = 0
;不同珠的编号列表，我这里直接声明出来了，不想写什么骚操作
#DIM PALAMNUMLIST = 0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,18,19,20,21,22,23,25,26,27,30
VARSET LOCAL, 0

FOR LCOUNT, 0, 26
	NUM = PALAMNUMLIST:LCOUNT
	LOCAL = CALC_JUEL(NUM)
	GOTJUEL:NUM = LOCAL
	PALAMCOUNT += LOCAL
NEXT

DRAWLINE
IF PALAMCOUNT > 0;
	;这里进行一个获取珠数的打印，并且对获取到的珠进行结算保存，由于全是程序狠活，就不抛出到UI界面了
	CALL SHOW_AND_GET_GOTJUEL
ELSE
	PRINTW 调教结果：没有得到任何珠。
ENDIF 

@SHOW_AND_GET_GOTJUEL
#DIM BEFORE_JUEL, 1
#DIM LCOUNT
;不同珠的编号列表，我这里直接声明出来了，不想写什么骚操作
#DIM PALAMNUMLIST = 0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,18,19,20,21,22,23,25,26,27,30
LOCAL = 0
PRINTL 调教结果：
FOR LCOUNT, 0, 26
	LOCAL = PALAMNUMLIST:LCOUNT
	;溢出对策也导入珠数调整的处理
	;另外，珠子的持有量不足1000万个（估计也不会用到那种程度）
	IF JUEL:LOCAL >= 9999999
		GOTJUEL:LOCAL = 9999999
	ELSEIF (JUEL:LOCAL + GOTJUEL:LOCAL) >= 9999999
		GOTJUEL:LOCAL = 9999999 - JUEL:LOCAL
	ENDIF

	;这里是珠数的计算打印出之前的珠数和获取到的珠数
	BEFORE_JUEL = JUEL:TARGET:LOCAL
	GOTJUEL:LOCAL = MAX(GOTJUEL:LOCAL, 0)

	;这里是对获取到的珠进行一个保存处理，将临时数据变为玩家自身数据
	JUEL:LOCAL = LIMIT(JUEL:LOCAL + GOTJUEL:LOCAL, 0, 9999999)

	SIF JUEL:LOCAL + GOTJUEL:LOCAL != 0
		PRINTFORML %PALAMNAME:LOCAL%之珠×({BEFORE_JUEL, 7} \@(GOTJUEL:LOCAL >= 0) ? ＋ # －\@ {ABS(GOTJUEL:LOCAL), 7} -> {JUEL:LOCAL, 7})
NEXT

PRINTW ……获得了以上的珠。

@CALC_JUEL(ARG)
#FUNCTION

GETPALAMLV PALAM:TARGET:ARG, 10
LOCAL = PALAMSOURLIST:RESULT

SIF RESULT == 1 && PALAM:TARGET:ARG >= PALAMLV:1*3
	LOCAL += 1
SIF RESULT == 2 && PALAM:TARGET:ARG >= PALAMLV:2*3
	LOCAL += 10
SIF RESULT == 3 && PALAM:TARGET:ARG >= PALAMLV:3*2
	LOCAL += 100

IF ARG >= 0 && ARG <= 3
	LOCAL = MIN(LOCAL + EX:ARG * 1000, 99999)
ELSEIF ARG == 20 || ARG == 21 || ARG == 22
	IF LOCAL > 99999 && FLAG:3 > 4
		LOCAL = 99999
	ELSEIF LOCAL > 10000
		LOCAL = 10000
	ENDIF
ENDIF
RETURNF LOCAL